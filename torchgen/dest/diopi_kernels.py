# Copyright (c) 2023, pjlab.org.cn
# All rights reserved.
#
# Licensed under the BSD 3-Clause License  (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://opensource.org/licenses/BSD-3-Clause
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from collections import defaultdict
from typing import Dict, Optional

import torchgen.api.cpp as cpp
import torchgen.api.meta as meta
from torchgen.api.translate import translate
from torchgen.api.types import (
    Binding,
    kernel_signature,
    BaseCType,
    NamedCType,
    tensorT,
    scalarT,
    ConstRefCType,
)
from torchgen.context import method_with_native_function, with_native_function_and_index
from torchgen.model import (
    Argument,
    BackendIndex,
    BackendMetadata,
    DispatchKey,
    NativeFunction,
)
from torchgen.utils import (
    assert_never,
    mapMaybe,
    FileManager,
    NamespaceHelper,
)


def gen_diopi_convert(
    binding: Binding,
    meta: BackendMetadata,
    args_map: Dict[str, str],
) -> Optional[str]:
    if binding.name in meta.diopi.args:
        name = binding.name + "_diopi"
        new_arg = NamedCType(
            name,
            BaseCType(cpp.diopi_type(binding.nctype.type))
        )
        # Put to map and add reference to scalar type
        args_map[binding.name] = name if binding.nctype.type != ConstRefCType(
            BaseCType(scalarT)) else "&" + name
        return f"::{new_arg.cpp_type()} {new_arg.name} = \
{cpp.diopi_type_helper(binding.nctype.type)}({binding.name});"
    else:
        return None


def gen_diopi_kernel(
    f: NativeFunction,
    backend_index: BackendIndex,
    fm: FileManager,
    cpp_namespace: str,
    backend_dispatch_key: DispatchKey,
) -> Optional[str]:

    metadata = backend_index.get_kernel(f)
    if metadata is None:
        return None
    if not metadata.diopi.full_gen:
        return None
    if "legacy::" in metadata.kernel:
        return None

    opname = f.root_name.capitalize()

    generated_comment = (
        "Autogenerated file by gen_dipu_stubs.py. Do not edit directly!"
    )

    sig = kernel_signature(f, backend_index)
    name = "DIPUATenFunctions::" + metadata.kernel
    kernel_defn = f"{sig.defn(name=name)}"

    args_map: Dict[str, str] = defaultdict()
    arguments_convert = list(
        mapMaybe(
            lambda f: gen_diopi_convert(f, metadata, args_map),
            sig.arguments()
        )
    )
    arguments_convert.append(
        # always add context convert
        "::diopiContext context(dipu::getCurrentDIPUStream().rawstream());"
    )

    infer = []
    adaptor = []
    diopi_invoke = [
        f"""\
::diopiError_t ret = ::{metadata.diopi.api}(&context, {", ".join(args_map[a] for a in metadata.diopi.args)});
TORCH_CHECK(ret == ::diopiSuccess, __func__, ":", __FILE__, ":", __LINE__,
  " {metadata.diopi.api} error, error code is ", ret, "\\nerror message is", diopiGetLastErrorString());
return {metadata.diopi.returnArg};"""
    ]

    ns_helper = NamespaceHelper(cpp_namespace)

    fm.write_with_template(
        f"{opname}Kernel{backend_dispatch_key}.cpp",
        "DiopiKernelDIPU.cpp",
        lambda: {
            "generated_comment": generated_comment,
            "namespace_prologue": ns_helper.prologue,
            "arguments_convert": arguments_convert,
            "namespace_epilogue": ns_helper.epilogue,
            "kernel_defn": kernel_defn,
            "infer": infer,
            "adaptor": adaptor,
            "diopi_invoke": diopi_invoke,
        },
    )
    